### **JVM ?**

Java Virtual Machine의 줄임말로 자바 프로그램 실행환경을 만들어주는 소프트웨어이다.

**JVM은 Java Application이 OS에 상관없이 실행할 수 있게 해준다.** (플랫폼으로부터 독립적이게 만들어 줌)

🌟 자바 바이트 코드 ( .class )를 OS에 맞는 코드로 변환하여 실행해주는 역할.

![JavaRuntime11](https://user-images.githubusercontent.com/80582237/215210215-ff3cd6ba-c788-4db5-aa95-049a714d6c49.png)

자바 어플리케이션의 실행과정

1.  자바 어플리케이션 실행
2.  JVM이 OS로부터 메모리를 할당받음 ( JVM은 할당받은 메모리를 용도에 따라 영역을 구분하여 관리 )
3.  자바 컴파일러 ( javac )가 자바 소스코드( .java )를 읽어 바이트 코드( .class )로 변환
4.  클래스 로더를 통해 변환된 바이트 코드를 JVM으로 로딩
5.  로딩된 바이트 코드는 실행 엔진을 통해 해석됨
6.  해석된 바이트 코드는 JVM 메모리 영역(Runtime Data Area)에 배치되어 실행됨

![자바프로그램_실행과정](https://user-images.githubusercontent.com/80582237/215210462-79afb6a7-e403-4043-8c61-64b75a4b61b3.png)

---

### **JVM의 구조**

![JVM_Structure](https://user-images.githubusercontent.com/80582237/215210619-15a98f28-4cbf-4c97-8424-97efb06a49ee.png)

JVM은 크게 아래와 같이 구성되어있다.

-   **클래스 로더 ( Class Loader )**
-   **메모리 ( Runtime Data Area )**
    -   Method Area
    -   PC ( Program Counter ) register
    -   Native method stack
    -   Stack
    -   Heap
-   **실행 엔진 ( Execution Engine )**
    -   인터프리터 ( Interpreter )
    -   JIT 컴파일러 ( Just-in-Time Compiler )
    -   가비지 컬렉터 ( Garbage Collector )

---

### **클래스 로더**

클래스 로더는 JVM 내로 컴파일된 자바 코드(.class)를 동적으로 로드하고, 링크를 통해 레퍼런스를 연결하는 과정을 거치고 static 값들 초기화 및 변수에 할당 후 JVM의 메모리 영역인 Runtime Data Area에 배치한다.

클래스를 메모리에 올리는 로딩 기능은 한번에 메모리에 올리지 않고, 어플리케이션에서 필요한 경우에 동적으로 메모리에 적재한다.

![ClassLoader4](https://user-images.githubusercontent.com/80582237/215210688-adaa5b8e-b8e7-4d9d-a0a3-6d6fe968171b.png)

클래스 로더는 3단계로 진행된다.

로딩 -> 링크 -> 초기화

-   **로딩 (Loading)** : 자바 바이트 코드( .class )를 **메소드 영역에 저장**한다. 로딩이 끝나면 해당 클래스 타입의 Class 객체를 생성하여 "힙(Heap)" 영역에 저장.
    -   **Bootstrap** : JAVA\_HOME/lib에 있는 코어 자바 API를 제공한다. (최상위 우선순위를 가진 클래스 로더)
    -   **확장 (Extension) || 플랫폼 클래스 로더** : 부트스트랩 클래스 로더를 부모로 갖는 클래스 로더로서, 확장 자바 클래스들을 로드한다. JAVA\_HOME/lib/ext 폴더 또는 java.ext.dirs 시스템 변수에 해당하는 위치에 있는 클래스를 읽는다.
    -   **Application** : Application 클래스 패스(어플리케이션을 실행할 때 주는 -classpath 옵션 또는 java.class.path 환경 변수의 값에 해당하는 위치)에서 클래스를 읽는다.
-   **링크 (Linking)**
    -   **검증 (Verifying)** : 읽어들인 클래스가 자바 언어 명세 및 JVM 명세에 명시된 대로 잘 구성되어 있는지 검사
    -   **준비 (Preparing)** : 클래스가 필요로 하는 메모리를 할당하고, 클래스에서 정의된 필드, 메소드, 인터페이스를 나타내는 데이터 구조를 준비
    -   **분석 (Resolving)** : 심볼릭 메모리 레퍼런스를 메소드 영역에 있는 실제 레퍼런스로 교체
-   **초기화 (Initialization)** : 클래스 변수들을 적절한 값으로 초기화 ( static 필드들이 설정된 값으로 초기화 )

---

**클래스 로더의 원칙 세가지**

-   유일성 원칙
-   위임 계층 원칙
-   가시범위 원칙

**유일성 원칙**

하위 클래스 로더가 상위 클래스 로더에서 로드한 클래스를 다시 로드하지 않아야 한다는 원칙.

이 원칙이 지켜지지 않는다면 JVM에 동일한 클래스가 2개 이상 로드되는 상황이 발생.

**위임 원칙**

클래스 로딩이 필요한 경우 부모 클래스 로더 방향으로 클래스 로딩을 위임하는 것.

1.  JVM의 Method Area에 클래스가 로드되어 있는지 확인한다. 만일 로드되어 있는 경우 해당 클래스를 사용한다.
2.  Method Area에 클래스가 로드되어 있지 않을 경우, 애플리케이션 클래스로더에 클래스 로드를 요청한다.
3.  애플리케이션 클래스로더는 확장 클래스로더에 클래스 로드를 요청한다.
4.  확장 클래스로더는 부트스트랩 클래스로더에 클래스 로드를 요청한다.
5.  부트스트랩 클래스로더는 부트스트랩 Classpath(JDK/JRE/LIB)에 해당 클래스가 있는지 확인한다. 클래스가 존재하지 않는 경우 확장 클래스로더가 요청을 수행하도록 한다.
6.  확장 클래스로더는 확장 Classpath(JDK/JRE/LIB/EXT)에 해당 클래스가 있는지 확인한다. 클래스가 존재하지 않는 경우 애플리케이션 클래스로더가 요청을 수행하도록 한다.
7.  애플리케이션 클래스로더는 애플리케이션 Classpath에 해당 클래스가 있는지 확인한다. 클래스가 존재하지 않는 경우 ClassNotFoundException을 발생시킨다.

**가시범위 원칙**

하위 클래스 로더는 상위 클래스로더가 로드한 클래스를 볼 수 있지만, 반대로 상위 클래스 로더는 하위 클래스 로더가 로드한 클래스를 알 수 없다.

---

### **실행 엔진이란?**

실행엔진은 메모리에 적재된 클래스(바이트 코드)들을 기계어로 변경하여 명령어 단위로 실행한다. 바이트 코드를 운영체제에 맞게 해석해주는 역할을 수행하며 크게 두 가지 방식을 사용한다.

-   인터프리터 (Interpreter)
-   JIT (Just In Time)

---

**인터프리터 (Interpreter)**

바이트 코드 명령어를 하나씩 읽어서 해석하고 바로 실행한다. 바이트 코드 한 줄씩 읽고 실행하는데 **중복되는 바이트 코드들에 대해서도 매번 컴파일 하게되어 속도가 느리다는 단점**이 있다. 따라서 **중복되는 바이트 코드에 대해서는 JIT 컴파일러를 사용**한다.

**JIT (Just In Time)**

인터프리터의 속도 문제를 해결하기 위해 생겨난 기능이며, 인터프리터로 먼저 컴파일을 하다가 반복되는 코드를 발견하면 JIT 컴파일러가 바이트 코드 전체를 네이티브 코드로 변경하고 해당 메서드를 **더 이상 인터프리팅 하지 않고 네이티브 코드로 직접 실행하는 방식**이다.

**가비지 컬렉터 (Garbage Collector)**

**Heap 메모리 영역**에 생성된 객체들 중에 **더 이상 참조되지 않는 객체들을 탐색 후 제거**해주는 역할을 한다. 

C언어 같은 경우 개발자가 직접 메모리 관리를 해줘야 하지만, JAVA에서는 이 GC를 사용하여 자동으로 메모리를 최적화 시켜준다.

---

### **런타임 데이터 영역 (Runtime Data Area - 메모리)**

런타임 데이터 영역은 자바 어플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역이다. 즉, 프로그램을 수행하기 위해 OS에서 할당받은 메모리 공간이다.

![RuntimeDataArea](https://user-images.githubusercontent.com/80582237/215223744-fec4c775-3c62-4f39-9a08-9af9b732339b.png)

런타임 데이터 영역은 다섯가지의 영역으로 나눌 수 있다.
 - Method Area
 - Heap Area
 - Stack Area
 - PC Register
 - Native Method Stack

이 중 Method Area, Heap Area는 모든 쓰레드가 공유하고, 나머지는 각 쓰레드마다 생성되는 영역이다.

**Method Area**

클래스 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보와 같은 각종 **필드 정보들과 메서드 정보, 데이터 타입 정보, static 변수, final class 등이 생성되는 영역**이다.이다.
이 영역은 JVM 당 하나만 생성이 되며, 인스턴스 생성에 필요한 정보도 존재하기 때문에 JVM에 **생성된 모든 쓰레드들이 공유**하게 된다.

JVM의 다른 메모리 영역에서 해당 정보에 대한 요청이 오면, 실제 물리 메모리 주소로 변환해서 전달해준다.
기초 역할을 하므로 JVM 구동 시작 시에 생성이 되며, 종료 시 까지 유지되는 영역이다.

> Rumtime Constant Pool
> 상수 자료형을 저장하여 참조하고 중복을 막는 역할을 수행하며 Method Area 영역에 포함되지만 별도의 관리영역이다.

**Heap Area**

Method Area와 같이 모든 쓰레드에서 공유가 되고, 코드 실행을 위한 객체 및 JRE 클래스들이 탑재된다.
문자열에 대한 정보를 가진 String Pool과 실제 데이터를 가진 인스턴스, 배열 등이 저장된다.

쉽게 말해 new 키워드로 생성된 객체와 배열이 저장되는 영역이다. 또한 참조되지 않는 인스턴스와 배열에 대한 정보를 얻을 수 있기 때문에 GC의 주 대상이 된다.

Heap 메모리는 인스턴스가 생성된 후 시간에 따라 5가지 부분으로 나눌 수 있는데 이 부분은 추후 따로 포스팅하도록 하겠다.

**Stack Area**

int, long, boolean 등 원시타입의 데이터가 값과 함께 할당되는 영역이며, 함수나 메서드의 지역 변수, 매개 변수가 저장된다.
함수나 메서드가 호출될 때 마다 스택 프레임이 스택 메모리 안에 쌓인다.
스택 영역은 각 스레드마다 하나씩 존재하며, 스레드가 시작될 때 할당된다. 어플리케이션 실행 중 지정된 메모리 크기를 넘어서게 되면 StackOverFlow가 발생하게 된다.

**PC Register**

쓰레드가 어떤 부분을 어떤 명령으로 실행해야할 지에 대한 기록을 하는 부분으로 **현재 수행 중인 JVM 명령의 주소를 저장하는 공간**이다.

자바에서 쓰레드는 각자의 메소드를 각자 실행하게 되는데 쓰레드 별로 동시에 실행하는 환경이 보장되어야 하므로 실행 중인 JVM에서는 명령어 주소값을 저장할 공간이 필요하다.
이러한 부분을 PC Register 영역이 관리해준다.

**Native Method Stack**

자바 코드가 컴파일되어 생성되는 바이트 코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행하는 영역이다.



